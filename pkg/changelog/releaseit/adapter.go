package releaseit

import (
	"bufio"
	"bytes"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"

	"mcp-changelog-promoter/pkg/changelog"
)

// Adapter handles changelogs likely generated by release-it (conventional-changelog).
type Adapter struct{}

// NewAdapter creates a new release-it adapter.
func NewAdapter() *Adapter {
	return &Adapter{}
}

// Matches lines like:
// ## [1.2.3](...) (YYYY-MM-DD)
// ### [v1.2.3](...) (YYYY-MM-DD)
// ## 0.1.1 (YYYY-MM-DD)
var versionRegex = regexp.MustCompile(`^#+\s+(?:\*\*\s?)?\[?(v?[\w\.\-]+)\]?(?:\([^)]*\))?\s*\(?(\d{4}-\d{2}-\d{2})\)?$`)

const maxDiffLines = 500 // Increased limit for full diff
const maxReadmeLines = 50

// parseSpecificVersionFromFile parses the CHANGELOG.md file and extracts the entry
// for the target version, without fetching diff or readme.
func parseSpecificVersionFromFile(changelogFilePath string, targetVersion string) (*changelog.VersionEntry, error) {
	file, err := os.Open(changelogFilePath)
	if err != nil {
		return nil, fmt.Errorf("打开 CHANGELOG.md 失败 (%s): %w", changelogFilePath, err)
	}
	defer file.Close()

	var currentEntry *changelog.VersionEntry
	var descriptionBuilder strings.Builder
	var found bool
	projectName := filepath.Base(filepath.Dir(changelogFilePath)) // Infer project name from dir

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		matches := versionRegex.FindStringSubmatch(line)

		if matches != nil && len(matches) >= 2 { // Need at least version
			parsedVersion := matches[1]
			parsedDate := "" // Date might be optional
			if len(matches) == 3 {
				parsedDate = matches[2]
			}

			// If we were accumulating description for the target version, stop.
			if found {
				break
			}

			// Normalize version (remove potential 'v' prefix for comparison)
			normalizedParsedVersion := strings.TrimPrefix(parsedVersion, "v")
			normalizedTargetVersion := strings.TrimPrefix(targetVersion, "v")

			if normalizedParsedVersion == normalizedTargetVersion {
				found = true
				currentEntry = &changelog.VersionEntry{
					ProjectName:   projectName,
					Version:       parsedVersion, // Keep original format
					Date:          parsedDate,
					SourceAdapter: "release-it", // Indicate the source
				}
			}
		} else if found {
			// Accumulate description lines until the next version header
			descriptionBuilder.WriteString(line)
			descriptionBuilder.WriteString("\n")
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("扫描 CHANGELOG.md 出错：%w", err)
	}

	if !found || currentEntry == nil {
		return nil, fmt.Errorf("未在 %s 中找到版本 %s", changelogFilePath, targetVersion)
	}

	currentEntry.Description = strings.TrimSpace(descriptionBuilder.String())
	return currentEntry, nil
}

// findLatestVersionInFile finds the first version mentioned in the CHANGELOG.md file.
func findLatestVersionInFile(changelogFilePath string) (string, error) {
	file, err := os.Open(changelogFilePath)
	if err != nil {
		return "", fmt.Errorf("打开 CHANGELOG.md 失败 (%s): %w", changelogFilePath, err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		matches := versionRegex.FindStringSubmatch(line)
		if matches != nil && len(matches) >= 2 {
			return matches[1], nil // Return the first version found
		}
	}

	if err := scanner.Err(); err != nil {
		return "", fmt.Errorf("扫描 CHANGELOG.md 出错：%w", err)
	}

	return "", fmt.Errorf("未能在 %s 中找到任何符合格式的版本", changelogFilePath)
}

// GetVersionEntry retrieves the full changelog entry for a specific version,
// including diff and readme.
func (a *Adapter) GetVersionEntry(repoPath string, version string) (*changelog.VersionEntry, error) {
	changelogFilePath := filepath.Join(repoPath, "CHANGELOG.md")

	// 1. Parse basic info from CHANGELOG.md
	entry, err := parseSpecificVersionFromFile(changelogFilePath, version)
	if err != nil {
		return nil, err // Propagate parsing error
	}

	// 2. Fetch Code Diff and Readme unconditionally
	var codeDiff, readmeContent string

	// Get Code Diff
	// Determine the version string to use with git commands (prefer 'v' prefix if missing)
	gitVersion := version
	if !strings.HasPrefix(version, "v") {
		// Check if the 'v' prefixed tag exists, maybe? For now, just try adding 'v'.
		// A more robust check could involve `git rev-parse --verify v<version>`
		// but that adds complexity and another command execution.
		// Let's assume 'v' prefix is the convention for tags if missing in changelog header.
		gitVersion = "v" + version
		log.Printf("Info: Original version '%s' doesn't start with 'v', trying git commands with '%s'", version, gitVersion)
	}

	prevTagCmd := exec.Command("git", "describe", "--tags", "--abbrev=0", gitVersion+"^")
	prevTagCmd.Dir = repoPath
	prevTagOutput, prevTagErr := prevTagCmd.Output()
	if prevTagErr == nil {
		prevTag := strings.TrimSpace(string(prevTagOutput))
		// Remove --stat to get full diff
		diffCmd := exec.Command("git", "diff", fmt.Sprintf("%s..%s", prevTag, gitVersion))
		diffCmd.Dir = repoPath
		var diffStderr bytes.Buffer
		diffCmd.Stderr = &diffStderr
		diffOutput, diffErr := diffCmd.Output()
		if diffErr == nil {
			codeDiff = string(diffOutput)
			// Truncate diff
			diffLines := strings.Split(codeDiff, "\n")
			if len(diffLines) > maxDiffLines {
				codeDiff = strings.Join(diffLines[:maxDiffLines], "\n") + "\n... (diff truncated)"
			}
		} else {
			log.Printf("Warning: 执行 git diff %s..%s 失败: %v, Stderr: %s", prevTag, gitVersion, diffErr, diffStderr.String())
			codeDiff = fmt.Sprintf("无法获取代码变更摘要 (git diff %s..%s): %v\nStderr: %s", prevTag, gitVersion, diffErr, diffStderr.String())
		}
	} else {
		log.Printf("Warning: 获取 %s 的上一个 tag 失败，尝试 git show: %v", gitVersion, prevTagErr)
		// Remove --stat to get full diff
		showCmd := exec.Command("git", "show", gitVersion)
		showCmd.Dir = repoPath
		var showStderr bytes.Buffer
		showCmd.Stderr = &showStderr
		showOutput, showErr := showCmd.Output()
		if showErr == nil {
			codeDiff = string(showOutput)
			// Truncate diff
			diffLines := strings.Split(codeDiff, "\n")
			if len(diffLines) > maxDiffLines {
				codeDiff = strings.Join(diffLines[:maxDiffLines], "\n") + "\n... (diff truncated)"
			}
		} else {
			log.Printf("Warning: 执行 git show %s 失败: %v, Stderr: %s", gitVersion, showErr, showStderr.String())
			codeDiff = fmt.Sprintf("无法获取代码变更摘要 (git show %s): %v\nStderr: %s", gitVersion, showErr, showStderr.String())
		}
	}

	// Read Readme
	readmePath := filepath.Join(repoPath, "README.md")
	readmeBytes, readErr := os.ReadFile(readmePath)
	if readErr == nil {
		readmeContent = string(readmeBytes)
		// Truncate Readme
		readmeLines := strings.Split(readmeContent, "\n")
		if len(readmeLines) > maxReadmeLines {
			readmeContent = strings.Join(readmeLines[:maxReadmeLines], "\n") + "\n... (Readme truncated)"
		}
	} else {
		log.Printf("Warning: 读取 README.md 失败 (%s): %v", readmePath, readErr)
		readmeContent = "无法读取 README.md。"
	}

	// 3. Add diff and readme to the entry
	entry.CodeDiff = strings.TrimSpace(codeDiff)
	entry.Readme = strings.TrimSpace(readmeContent)

	return entry, nil
}

// GetLatestEntry gets the full changelog entry for the latest tag.
func (a *Adapter) GetLatestEntry(repoPath string) (*changelog.VersionEntry, error) {
	changelogFilePath := filepath.Join(repoPath, "CHANGELOG.md")

	// 1. Find the latest version string from the file
	latestVersion, err := findLatestVersionInFile(changelogFilePath)
	if err != nil {
		return nil, err // Propagate error
	}

	// 2. Get the full entry details for the latest version
	return a.GetVersionEntry(repoPath, latestVersion)
}
